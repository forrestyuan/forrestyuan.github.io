<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[心的革念]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%BF%83%E7%9A%84%E9%9D%A9%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[现在是2019年4月3日，突然发现自己在两年前创建的博客，很久没有更新的，当时可能也是抱着好奇的心态，以三分钟热度的激情，在自己的电脑上敲下各种命令行（Hexo,node）搭建好了写博客的环境。 当时搭建好环境后，几天内，壮志满满在日更博客内容，可是，一股新鲜劲过后，就放在了魔法记忆盒的最角处，是从未见过天日。 今天重新把它从角落里拽出来，擦干净，准备再次点燃写博客的激情。 在以前，自己在学习完一个新的知识点之后，总是会首先把知识点记录在纸上，但自己也总想把它记录在一个博客上，不仅自己日后可以翻看，也可以让有需要的人得到帮助。 我是一名前端er，截至目前，毕业已近一年，在一家汉化的外企上班，朝九晚五，就工作强度而言，我觉得是很小的，这也充分给了自己额外空余的时间学习新的技术点。 前端界的知识点是日新月异，今天出A框架，明天出B框架。这个月才某某框架2.0,下月就是某某框架4.0。作为一名前端er，激昂的斗志，无限的激情，是啃下各个新知识的必要前提。 除开技术书，其它方面的书籍也是必不可少的，知识的深度绝不是在技术书的堆砌而成，希望自己能翻开新的篇章。一切的希望都建立在自己的努力上。加油！ by the way: 我叫 fox]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS,AMD,CMD 浅析]]></title>
    <url>%2F2018%2F01%2F11%2FCommonJS-AMD-CMD-%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JS模块化：模块通常是指一种代码组织方式，可将程序拆解为独立且通用的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生产环境时的自动化打包与处理等多个方面。优点： 代码重用：编写好的代码模块可以重复引用。 避免变量污染：模块与模块之间的代码所声明的变量不会产生冲突，具有独立的作用域。 高可维护性：编写好的模块在需要升级代码时，只需要对模块单元进行修改。 在开发模块时，开发人员不能各行其道，需要按照一定的规则编写代码，这样的代码才能被彼此引用，于是，便有了 CommonJS, AMD, CMD 这三种规范。 三种模块化规范的区别 CommonJS 需要三个参数 （require, exports, module) AMD （define 方法需要三个参数：模块名称，模块运行的依赖数组，所有依赖都可用之后执行的函数) CMD (全局函数define，用来定义模块。 参数 factory 可以是一个函数，也可以为对象或者字符串。 当 factory 为对象、字符串时，表示模块的接口就是该对象、字符串) 12345678/*commonJS*///通常我们在编写一个基于CommonJS规范的模块时，我们并不需要在定义require，module,exports这三个变量，因为在Node中，在编译的过程中，Node对获得javascript文件进行了头尾包装。被包装后的格式如下：(function(exports,require,module,__filename,__dirname)&#123; var math = require('math'); exports.area = function(radius)&#123; return Math.PI * radius * radius; &#125;&#125;); 1234/*AMD*/define(['dep1', 'dep2'], function(dep1, dep2)&#123; return function()&#123;&#125;;&#125;); 1234567/*CMD*///CMD规范是由国内的玉伯提出,与AMD相比，更接近CommonJS 规范define(factory);//在依赖部分，CMD支持动态引入，如下：define(function(require, exports, module)&#123; //The module code goes here;&#125;) AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs. CommonJs主要针对服务端，AMD/CMD主要针对浏览器端，所以最容易混淆的是AMD/CMD。 AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别。AMD是预加载：在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）CMD是按需加载：加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。 AMD/CMD的优缺点.AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。]]></content>
      <tags>
        <tag>前端大法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 机器学习 ipynb 文件的打开]]></title>
    <url>%2F2018%2F01%2F06%2Fpython-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-ipynb-%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%2F</url>
    <content type="text"><![CDATA[如何查看ipynb文件ipynb文件ipynb文件可以帮助我们重现数据处理分析的过程。打开这类文件不仅需要Python运行环境还需要ipython。 windows下打开.ipynb文件123456781.首先要下载python，设置环境变量2.下载pip，设置环境变量3.打开命令行，按顺序执行下面两个命令 pip install ipython pip install “ipython[notebook]”4.安装好后，进入ipynb 文件所在目录输入如下命令： ipython notebook 打开效果：输入上面第4条命令后，浏览器会自动打开该文件：]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 的操作指令]]></title>
    <url>%2F2017%2F12%2F26%2Fgit-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git的使用一、git的基本操作1、git init –初始化仓库要使用Git进行版本管理，必须先初始化仓库。Git是使用 git init 命令初始化的。建立一个目录并初始化仓库： 1234$ mkdir git-tutorial$ cd git-tutorial$ git init...初始化信息提示 如果初始化成功,执行了git init命令的目录下就会生成.git目录。这个.git目录里存储着管理当前目录内容所需的仓库数据。 2、 git status –查看仓库的状态git status 命令用于显示Git仓库的状态。这是一个十分常用的命令，务必牢记。工作树和仓库在被操作的过程中，状态会不断发生变化。在Git操作过程中时常使用此命令查看状态。 123456$ git status#On branch master##Initial commit#nothing to commit(create/copy files and use "git add" to break) 上述执行了命令后的结果显示，当前正处于master 分支下。并且表示尚没有可提交的内容。我们可以在项目仓库目录下创建一个readme.md文件： 123456789$ touch README.md$ git status# On branch master## Initial commit## Unctracked files:# (use "git add &lt;file&gt;..." to include in what will be committed)## README.mdnothing added to commit but untracked files present(use "git add "to track) 可以看到在Untracked files 中显示了 README.md 文件。类似的，只要对Git的工作树或仓库进行操作，git status 命令的显示结果就会发生变化。 3、 git add –向暂存区添加文件仅用git仓库的工作树创建了文件，该文件并不会被记入Git 仓库的版本管理对象中。要想让文件成为Git仓库的管理对象，就需要用 git add命令将其加入暂存区（Stage 或者 Index）中。暂存区是提交之前的一个临时区域。 $ git add README.md 4、 git commit –保存仓库的历史记录git commit 命令可以将当前暂存区中的文件实际保存到仓库的历史记录中。 1$ git commit -m "First commit" -m参数后的”First commit”称作提交信息，是对这个提交的概述。 5、 git log –查看提交日志git log 命令可以查看以往仓库提交的日志。包括可以查看什么人在什么时候进行了提交或合并，以及操作前后有怎样的差别。关于合并我们会在后面解说。 1234$ git logcommit xxxxAuthor: ****Date: sun May 5 16:06:49 2013 +0900 如上所示,commit栏显示的提交的哈希值。Git的其他命令中在指向提交时会用到这个哈希值。Author栏显示的提交的用户名和邮箱地址。Date栏中显示提交执行的日期和时间。再往下就是提交的信息。 6、 git diff –查看更改前后的差别git diff 命令可以查看工作树，暂存区，最新提交之间的区别。在README.md中写点东西 # Git 教程执行git diff,查看当前工作树和暂存区的差别。 12345678$ git diffdiff --git a/README.md b/README.mdindex (hash 值)--- a/README.md+++ b/README.md@@ -0 , 0 +1 @@+# Git教程 其中”+”表示新增加的行，”-“表示被删除的行。 二、git分支的操作在进行多个并行作业是，常会用到分支。不同的分支中可以同时进行完全不同的作业。等该分支的作业完成后再与master分支合并。 1、git branch –显示分支一览表git branch 命令可以将分支名列表显示，同时可以确认当前所在分支。 12$ git branch* master 上面的*号表示当前处于master 分支下，且在该分支下进行开发，而且当前仅有一个master 分支。 2、git checkout -b –创建、切换分支如果想以当前的master分支为基础创建新的分支，我们需要用到git checkout -b 命令 123456$git checkout -b feature-a#Switched to a new branch 'feature-a'等同于$ git branch feature-a$ git checkout feature-a表示创建分支并切换分支。 3、git merge –合并分支分支在功能特性开发完成后，往往需要讲这些特性添加到主分支中，此时就需要将分支合并。 首先切换到主分支master分支 12$ git checkout master#Switched to branch 'master' 合并分支 $ git merge --no-ff feature-a 三、更改提交的操作1、git reset –回溯历史版本12$ git reset --hard &lt;hash值&gt;#HEAD is now at **** Add index 2、消除冲突假如此时有两个分支，A和B ，A分支里的README.md 里有aaa内容，B分支里的README.md里有bbb内容，此时，A分支更改的部分与本次想要合并的fix-B分支更改的部分发生冲突。解决冲突：打开冲突文件更改冲突的部分。 四、推送至远程仓库1、git remote add –添加远程仓库git remote add origin &lt;远程仓库地址&gt; 2、git push –推送至远程仓库 推送至master分支：$ git push -u origin master 推送至master以外的分支： 12$ git checkout -b feature-a$ git push -u origin feature 如果执行git remote add origin &lt;远程仓库地址&gt;，出现错误：fatal: remote origin already exists 则执行以下语句：git remote rm origin再往后执行git remote add origin &lt;远程仓库地址&gt;即可. 在执行git push -u origin feature时，报错：error:failed to push som refs to.......则执行以下语句：git pull origin master先把远程服务器github上面的文件拉先来，再push 上去。 五、从远程仓库获取1、git clone –获取远程仓库git clone &lt;仓库远程地址&gt; 2、git pull –获取最新远程仓库分支$ git pull origin feature-a 六、推荐： Pro Git (一部零基础的Git学习资料) LearnGitBranching（学习git基本操作的网站） tryGit（可以以便操作一边学习Git的基本功能）]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub SSH Key的设置]]></title>
    <url>%2F2017%2F12%2F26%2FGitHub-SSH-Key%E7%9A%84%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[GitHub SSH Key的设置一、开通github账号首先前往github 官网创建一个账号。（根据官网提示操作） 二、关于SSH KeyGitHub 上链接已有仓库时的认证，是通过使用SSH的公开密钥认证方式进行的。现在让我们来创建公开密钥认证所需要的SSH Key,并将其添加到GitHub. SSH key提供了一种与GitHub通信的方式，通过这种方式，能够在不输入密码的情况下，将GitHub作为自己的remote端服务器，进行版本控制 三、设置步骤 检查SSH keys是否存在 （如不存在）生成新的ssh key 将ssh key添加到GitHub中 1、检查SSH keys12ls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 2、运行下面的命令创建SSH key：12345678$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/privater rsas key pair.Enter file in which to save the key(/Users/your_user_directory/.ssh/id_rsa):(按回车键)Enter passphrase (empty for no passphrase):(输入密码)Enter same passphrase again:(再次输入密码) &quot;your_email@example.com&quot;的部分改成您在创建github账户时用的邮箱地址，棉麻需要在认证时输入，请选择复杂度高并且容易记忆的组合。 输入密码后会出现如下结果： 1234567891011Your identification has been saved in /Users/your_user_directory/.ssh/id_rsa.Your identification has been saved in/Users/your_user_directory/.ssh/id_rsa.The key fingerprint is:(fingerprint 的值)your_email@example.comThe Key&apos;s randomart image is:+--[ RAS 2048 ]----+| .+ + || = o O . |.... id_rsa文件是私有密钥，id_rsa.pub是公开密钥。 3、添加公开密钥在github中添加公开密钥，用自己喜欢的文本编辑器打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到GitHub的Add SSH key页面即可。 完成添加后，就可以用手中的私人密钥与github进行认证通信了。 1234$ ssh -T git@github.comThe authenticity of host &apos;github.com(207.97.227.239)&apos; cnt&apos;t be established. RSA key fingerprint is (fingerprint的值) Are you sure you want to coninue connnection(yes/no)? (输入yes) 出现如下结果即为成功。 1Hi hirocastest! You&apos;ve successfully authenticated, but GitHub does not provide shell access.]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
